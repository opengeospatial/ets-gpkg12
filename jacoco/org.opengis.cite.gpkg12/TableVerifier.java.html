<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TableVerifier.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoPackage 1.2 Conformance Test Suite</a> &gt; <a href="index.source.html" class="el_package">org.opengis.cite.gpkg12</a> &gt; <span class="el_source">TableVerifier.java</span></div><h1>TableVerifier.java</h1><pre class="source lang-java linenums">package org.opengis.cite.gpkg12;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

/**
 * @author Luke Lambert
 */
public final class TableVerifier {

	// Not meant to instantiate
	private TableVerifier() {

	}

	public static void verifyTable(final Connection connection, final String tableName,
			final Map&lt;String, ColumnDefinition&gt; expectedColumns, final Set&lt;ForeignKeyDefinition&gt; expectedForeinKeys,
			final Iterable&lt;UniqueDefinition&gt; expectedGroupUniques) throws SQLException {
<span class="fc" id="L30">		verifyTableDefinition(connection, tableName);</span>

<span class="fc" id="L32">		final Set&lt;UniqueDefinition&gt; uniques = getUniques(connection, tableName);</span>

<span class="fc" id="L34">		verifyColumns(connection, tableName, expectedColumns, uniques);</span>

<span class="fc" id="L36">		verifyForeignKeys(connection, tableName, expectedForeinKeys);</span>

<span class="fc" id="L38">		verifyGroupUniques(tableName, expectedGroupUniques, uniques);</span>
<span class="fc" id="L39">	}</span>

	private static void verifyTableDefinition(final Connection connection, final String tableName) throws SQLException {
<span class="fc" id="L42">		try (final PreparedStatement statement = connection.prepareStatement(</span>
				&quot;SELECT sql FROM sqlite_master WHERE (type = 'table' OR type = 'view') AND tbl_name = ?;&quot;)) {
<span class="fc" id="L44">			statement.setString(1, tableName);</span>

<span class="fc" id="L46">			try (ResultSet gpkgContents = statement.executeQuery()) {</span>
<span class="pc bpc" id="L47" title="1 of 2 branches missed.">				if (gpkgContents.getString(&quot;sql&quot;) == null) {</span>
<span class="nc" id="L48">					throw new RuntimeException(</span>
<span class="nc" id="L49">							String.format(&quot;The `sql` field must include the %s table SQL Definition.&quot;, tableName)); // TODO</span>
																													// this
																													// needs
																													// to
																													// be
																													// in
																													// the
																													// error
																													// string
																													// table
				}
			}
		}
<span class="fc" id="L62">	}</span>

	private static Set&lt;UniqueDefinition&gt; getUniques(final Connection connection, final String tableName)
			throws SQLException {
<span class="fc" id="L66">		try (final Statement statement = connection.createStatement();</span>
<span class="fc" id="L67">				final ResultSet indices = statement.executeQuery(String.format(&quot;PRAGMA index_list(%s);&quot;, tableName))) {</span>
<span class="fc" id="L68">			final Set&lt;UniqueDefinition&gt; uniqueDefinitions = new HashSet&lt;&gt;();</span>

<span class="fc bfc" id="L70" title="All 2 branches covered.">			while (indices.next()) {</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">				if (indices.getBoolean(&quot;unique&quot;)) {</span>
<span class="fc" id="L72">					final String indexName = indices.getString(&quot;name&quot;);</span>

<span class="fc" id="L74">					try (Statement nameStatement = connection.createStatement();</span>
<span class="fc" id="L75">							ResultSet namesSet = nameStatement</span>
<span class="fc" id="L76">								.executeQuery(String.format(&quot;PRAGMA index_info(%s);&quot;, indexName))) {</span>
<span class="fc" id="L77">						final List&lt;String&gt; names = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L79" title="All 2 branches covered.">						while (namesSet.next()) {</span>
<span class="fc" id="L80">							names.add(namesSet.getString(&quot;name&quot;));</span>
						}

<span class="fc" id="L83">						uniqueDefinitions.add(new UniqueDefinition(names));</span>
					}
<span class="fc" id="L85">				}</span>
			}

<span class="fc" id="L88">			return uniqueDefinitions;</span>
		}
	}

	private static void verifyColumns(final Connection connection, final String tableName,
			final Map&lt;String, ColumnDefinition&gt; requiredColumns, final Collection&lt;UniqueDefinition&gt; uniques)
			throws SQLException {
<span class="fc" id="L95">		try (final Statement statement = connection.createStatement();</span>
<span class="fc" id="L96">				final ResultSet tableInfo = statement</span>
<span class="fc" id="L97">					.executeQuery(String.format(&quot;PRAGMA table_info(%s);&quot;, tableName))) {</span>
<span class="fc" id="L98">			final Map&lt;String, ColumnDefinition&gt; columns = new TreeMap&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span>

<span class="fc bfc" id="L100" title="All 2 branches covered.">			while (tableInfo.next()) {</span>
<span class="fc" id="L101">				final String columnName = tableInfo.getString(&quot;name&quot;);</span>
<span class="fc" id="L102">				columns.put(columnName,</span>
<span class="fc" id="L103">						new ColumnDefinition(tableInfo.getString(&quot;type&quot;), tableInfo.getBoolean(&quot;notnull&quot;),</span>
<span class="fc" id="L104">								tableInfo.getBoolean(&quot;pk&quot;),</span>
<span class="fc" id="L105">								uniques.stream().anyMatch(unique -&gt; unique.equals(columnName)),</span>
<span class="fc" id="L106">								tableInfo.getString(&quot;dflt_value&quot;)));</span>
<span class="fc" id="L107">			}</span>

			// Make sure the required fields exist in the table
<span class="fc bfc" id="L110" title="All 2 branches covered.">			for (final Map.Entry&lt;String, ColumnDefinition&gt; column : requiredColumns.entrySet()) {</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">				if (!columns.containsKey(column.getKey())) {</span>
<span class="fc" id="L112">					throw new RuntimeException(</span>
<span class="fc" id="L113">							String.format(&quot;Required column: %s.%s is missing&quot;, tableName, column.getKey())); // TODO</span>
																												// this
																												// needs
																												// to
																												// be
																												// in
																												// the
																												// error
																												// string
																												// table
				}

				// We shouldn't be picky on table defaults as long as the content is
				// correct
<span class="fc" id="L127">				final ColumnDefinition columnDefinition = columns.get(column.getKey());</span>

<span class="pc bpc" id="L129" title="1 of 2 branches missed.">				if (columnDefinition != null) {</span>
<span class="pc bpc" id="L130" title="2 of 4 branches missed.">					if (!columnDefinition.equals(column.getValue()) || !checkExpressionEquivalence(connection,</span>
<span class="fc" id="L131">							columnDefinition.getDefaultValue(), column.getValue().getDefaultValue())) {</span>
<span class="nc" id="L132">						throw new RuntimeException(</span>
<span class="nc" id="L133">								String.format(&quot;Required column %s is defined as:\n%s\nbut should be:\n%s&quot;,</span>
<span class="nc" id="L134">										column.getKey(), columnDefinition.toString(), column.getValue().toString()));</span>
					}
				}
<span class="fc" id="L137">			}</span>
		}
<span class="fc" id="L139">	}</span>

	/**
	 * .equals() for ColumnDefinition skips comparing default values. It's better to check
	 * for functional equivalence rather than exact string equality. This avoids issues
	 * with difference in white space as well as other trivial annoyances.
	 * @param connection
	 * @param definition
	 * @param required
	 * @return
	 * @throws SQLException
	 */
	private static boolean checkExpressionEquivalence(final Connection connection, final String definition,
			final String required) throws SQLException {
<span class="pc bpc" id="L153" title="1 of 4 branches missed.">		if ((definition == null) || (required == null)) {</span>
<span class="pc bpc" id="L154" title="2 of 4 branches missed.">			return (definition == null) &amp;&amp; (required == null);</span>
		}

		// Sometimes people use a synonym here and functional equivalence
		// isn't possible because now is always changing
<span class="fc bfc" id="L159" title="All 2 branches covered.">		if (required.replaceAll(&quot;\\s+&quot;, &quot;&quot;).equalsIgnoreCase(&quot;strftime('%Y-%m-%dT%H:%M:%fZ','now')&quot;)) {</span>
<span class="fc" id="L160">			if (definition.replaceAll(&quot;\\s+&quot;, &quot;&quot;)</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">				.equalsIgnoreCase(&quot;strftime('%Y-%m-%dT%H:%M:%fZ',current_timestamp)&quot;)) {</span>
<span class="fc" id="L162">				return true;</span>
			}
		}

<span class="fc" id="L166">		try (final Statement statement = connection.createStatement()) {</span>
<span class="fc" id="L167">			final String query = String.format(&quot;SELECT (%s) = (%s);&quot;, definition, required);</span>

<span class="fc" id="L169">			try (final ResultSet results = statement.executeQuery(query)) {</span>
<span class="pc bpc" id="L170" title="2 of 4 branches missed.">				return results.next() &amp;&amp; results.getBoolean(1);</span>
			}
		}
	}

	private static void verifyForeignKeys(final Connection connection, final String tableName,
			final Set&lt;ForeignKeyDefinition&gt; requiredForeignKeys) throws SQLException {
<span class="fc" id="L177">		try (final Statement statement = connection.createStatement()) {</span>
<span class="fc" id="L178">			try (final ResultSet fkInfo = statement</span>
<span class="fc" id="L179">				.executeQuery(String.format(&quot;PRAGMA foreign_key_list(%s);&quot;, tableName))) {</span>
<span class="fc" id="L180">				final List&lt;ForeignKeyDefinition&gt; foundForeignKeys = new LinkedList&lt;&gt;();</span>

<span class="fc bfc" id="L182" title="All 2 branches covered.">				while (fkInfo.next()) {</span>
<span class="fc" id="L183">					foundForeignKeys.add(new ForeignKeyDefinition(fkInfo.getString(&quot;table&quot;), fkInfo.getString(&quot;from&quot;),</span>
<span class="fc" id="L184">							fkInfo.getString(&quot;to&quot;)));</span>
				}

<span class="fc" id="L187">				final Collection&lt;ForeignKeyDefinition&gt; missingKeys = new HashSet&lt;&gt;(requiredForeignKeys);</span>
<span class="fc" id="L188">				missingKeys.removeAll(foundForeignKeys);</span>

<span class="fc" id="L190">				final Collection&lt;ForeignKeyDefinition&gt; extraneousKeys = new HashSet&lt;&gt;(foundForeignKeys);</span>
<span class="fc" id="L191">				extraneousKeys.removeAll(requiredForeignKeys);</span>

<span class="fc" id="L193">				final StringBuilder error = new StringBuilder();</span>

<span class="pc bpc" id="L195" title="1 of 2 branches missed.">				if (!missingKeys.isEmpty()) {</span>
<span class="nc" id="L196">					error.append(String.format(&quot;The table %s is missing the foreign key constraint(s): \n&quot;, tableName));</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">					for (final ForeignKeyDefinition key : missingKeys) {</span>
<span class="nc" id="L198">						error.append(String.format(&quot;%s.%s -&gt; %s.%s\n&quot;, tableName, key.getFromColumnName(),</span>
<span class="nc" id="L199">								key.getReferenceTableName(), key.getToColumnName()));</span>
<span class="nc" id="L200">					}</span>
				}

<span class="pc bpc" id="L203" title="1 of 2 branches missed.">				if (!extraneousKeys.isEmpty()) {</span>
<span class="nc" id="L204">					error.append(String.format(&quot;The table %s has extraneous foreign key constraint(s): \n&quot;, tableName));</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">					for (final ForeignKeyDefinition key : extraneousKeys) {</span>
<span class="nc" id="L206">						error.append(String.format(&quot;%s.%s -&gt; %s.%s\n&quot;, tableName, key.getFromColumnName(),</span>
<span class="nc" id="L207">								key.getReferenceTableName(), key.getToColumnName()));</span>
<span class="nc" id="L208">					}</span>
				}

<span class="pc bpc" id="L211" title="1 of 2 branches missed.">				if (error.length() != 0) {</span>
<span class="nc" id="L212">					throw new RuntimeException(error.toString()); // TODO this needs to be</span>
																	// in the error string
																	// table
				}
			}
<span class="nc" id="L217">			catch (final SQLException ignored) {</span>
				// If a table has no foreign keys, executing the query
				// PRAGMA foreign_key_list(&lt;table_name&gt;) will throw an
				// exception complaining that result set is empty.
				// The issue has been posted about it here:
				// https://bitbucket.org/xerial/sqlite-jdbc/issue/162/
				// If the result set is empty (no foreign keys), there's no
				// work to be done. Unfortunately .executeQuery() may throw an
				// SQLException for other reasons that may require some
				// attention.
<span class="fc" id="L227">			}</span>
		}
<span class="fc" id="L229">	}</span>

	private static void verifyGroupUniques(final String tableName,
			final Iterable&lt;UniqueDefinition&gt; requiredGroupUniques, final Collection&lt;UniqueDefinition&gt; uniques) {
<span class="fc bfc" id="L233" title="All 2 branches covered.">		for (final UniqueDefinition groupUnique : requiredGroupUniques) {</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">			if (!uniques.contains(groupUnique)) {</span>
<span class="nc" id="L235">				throw new RuntimeException(</span>
<span class="nc" id="L236">						String.format(&quot;The table %s is missing the column group unique constraint: (%s)&quot;, tableName,</span>
<span class="nc" id="L237">								String.join(&quot;, &quot;, groupUnique.getColumnNames())));</span>
			}
<span class="fc" id="L239">		}</span>
<span class="fc" id="L240">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>