<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XMLUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoPackage 1.2 Conformance Test Suite</a> &gt; <a href="index.source.html" class="el_package">org.opengis.cite.gpkg12.util</a> &gt; <span class="el_source">XMLUtils.java</span></div><h1>XMLUtils.java</h1><pre class="source lang-java linenums">package org.opengis.cite.gpkg12.util;

import java.io.IOException;
import java.io.OutputStream;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import net.sf.saxon.s9api.DOMDestination;
import net.sf.saxon.s9api.DocumentBuilder;
import net.sf.saxon.s9api.Processor;
import net.sf.saxon.s9api.SaxonApiException;
import net.sf.saxon.s9api.XPathCompiler;
import net.sf.saxon.s9api.XPathSelector;
import net.sf.saxon.s9api.XQueryCompiler;
import net.sf.saxon.s9api.XQueryEvaluator;
import net.sf.saxon.s9api.XQueryExecutable;
import net.sf.saxon.s9api.XdmNode;
import net.sf.saxon.s9api.XdmValue;
import net.sf.saxon.s9api.XsltCompiler;
import net.sf.saxon.s9api.XsltExecutable;
import net.sf.saxon.s9api.XsltTransformer;

/**
 * Provides various utility methods for accessing or manipulating XML representations.
 */
<span class="nc" id="L64">public class XMLUtils {</span>

<span class="fc" id="L66">	private static final Logger LOGR = Logger.getLogger(XMLUtils.class.getPackage().getName());</span>

<span class="fc" id="L68">	private static final XMLInputFactory STAX_FACTORY = initXMLInputFactory();</span>

<span class="fc" id="L70">	private static final XPathFactory XPATH_FACTORY = initXPathFactory();</span>

	private static XPathFactory initXPathFactory() {
<span class="fc" id="L73">		XPathFactory factory = XPathFactory.newInstance();</span>
<span class="fc" id="L74">		return factory;</span>
	}

	private static XMLInputFactory initXMLInputFactory() {
<span class="fc" id="L78">		XMLInputFactory factory = XMLInputFactory.newInstance();</span>
<span class="fc" id="L79">		factory.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);</span>
<span class="fc" id="L80">		return factory;</span>
	}

	/**
	 * Writes the content of a DOM Node to a string. The XML declaration is omitted and
	 * the character encoding is set to &quot;US-ASCII&quot; (any character outside of this set is
	 * serialized as a numeric character reference).
	 * @param node The DOM Node to be serialized.
	 * @return A String representing the content of the given node.
	 */
	public static String writeNodeToString(Node node) {
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">		if (null == node) {</span>
<span class="nc" id="L92">			return &quot;&quot;;</span>
		}
<span class="fc" id="L94">		Writer writer = null;</span>
		try {
<span class="fc" id="L96">			Transformer idTransformer = TransformerFactory.newInstance().newTransformer();</span>
<span class="fc" id="L97">			Properties outProps = new Properties();</span>
<span class="fc" id="L98">			outProps.setProperty(OutputKeys.ENCODING, &quot;US-ASCII&quot;);</span>
<span class="fc" id="L99">			outProps.setProperty(OutputKeys.OMIT_XML_DECLARATION, &quot;yes&quot;);</span>
<span class="fc" id="L100">			outProps.setProperty(OutputKeys.INDENT, &quot;yes&quot;);</span>
<span class="fc" id="L101">			idTransformer.setOutputProperties(outProps);</span>
<span class="fc" id="L102">			writer = new StringWriter();</span>
<span class="fc" id="L103">			idTransformer.transform(new DOMSource(node), new StreamResult(writer));</span>
		}
<span class="nc" id="L105">		catch (TransformerException ex) {</span>
<span class="nc" id="L106">			TestSuiteLogger.log(Level.WARNING, &quot;Failed to serialize node &quot; + node.getNodeName(), ex);</span>
<span class="fc" id="L107">		}</span>
<span class="fc" id="L108">		return writer.toString();</span>
	}

	/**
	 * Writes the content of a DOM Node to a byte stream. An XML declaration is always
	 * omitted.
	 * @param node The DOM Node to be serialized.
	 * @param outputStream The destination OutputStream reference.
	 */
	public static void writeNode(Node node, OutputStream outputStream) {
		try {
<span class="nc" id="L119">			Transformer idTransformer = TransformerFactory.newInstance().newTransformer();</span>
<span class="nc" id="L120">			Properties outProps = new Properties();</span>
<span class="nc" id="L121">			outProps.setProperty(OutputKeys.METHOD, &quot;xml&quot;);</span>
<span class="nc" id="L122">			outProps.setProperty(OutputKeys.ENCODING, &quot;UTF-8&quot;);</span>
<span class="nc" id="L123">			outProps.setProperty(OutputKeys.OMIT_XML_DECLARATION, &quot;yes&quot;);</span>
<span class="nc" id="L124">			outProps.setProperty(OutputKeys.INDENT, &quot;yes&quot;);</span>
<span class="nc" id="L125">			idTransformer.setOutputProperties(outProps);</span>
<span class="nc" id="L126">			idTransformer.transform(new DOMSource(node), new StreamResult(outputStream));</span>
		}
<span class="nc" id="L128">		catch (TransformerException ex) {</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">			String nodeName = (node.getNodeType() == Node.DOCUMENT_NODE)</span>
<span class="nc" id="L130">					? Document.class.cast(node).getDocumentElement().getNodeName() : node.getNodeName();</span>
<span class="nc" id="L131">			TestSuiteLogger.log(Level.WARNING, &quot;Failed to serialize DOM node: &quot; + nodeName, ex);</span>
<span class="nc" id="L132">		}</span>
<span class="nc" id="L133">	}</span>

	/**
	 * Writes the result of a transformation to a String. An XML declaration is always
	 * omitted.
	 * @param result An object (DOMResult or StreamResult) that holds the result of a
	 * transformation, which may be XML or plain text.
	 * @return A String representing the content of the result; it may be empty if the
	 * content could not be read.
	 */
	public static String resultToString(Result result) {
<span class="nc bnc" id="L144" title="All 2 branches missed.">		if (null == result) {</span>
<span class="nc" id="L145">			throw new IllegalArgumentException(&quot;Result is null.&quot;);</span>
		}
<span class="nc" id="L147">		StringWriter writer = new StringWriter();</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">		if (result instanceof DOMResult) {</span>
<span class="nc" id="L149">			Node node = DOMResult.class.cast(result).getNode();</span>
<span class="nc" id="L150">			Properties outProps = new Properties();</span>
<span class="nc" id="L151">			outProps.setProperty(OutputKeys.ENCODING, &quot;UTF-8&quot;);</span>
<span class="nc" id="L152">			outProps.setProperty(OutputKeys.OMIT_XML_DECLARATION, &quot;yes&quot;);</span>
<span class="nc" id="L153">			outProps.setProperty(OutputKeys.INDENT, &quot;yes&quot;);</span>
			Transformer idTransformer;
			try {
<span class="nc" id="L156">				idTransformer = TransformerFactory.newInstance().newTransformer();</span>
<span class="nc" id="L157">				idTransformer.setOutputProperties(outProps);</span>
<span class="nc" id="L158">				idTransformer.transform(new DOMSource(node), new StreamResult(writer));</span>
			}
<span class="nc" id="L160">			catch (TransformerFactoryConfigurationError | TransformerException e) {</span>
<span class="nc" id="L161">				LOGR.warning(e.getMessage());</span>
<span class="nc" id="L162">			}</span>
<span class="nc" id="L163">		}</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">		else if (result instanceof StreamResult) {</span>
<span class="nc" id="L165">			StreamResult streamResult = StreamResult.class.cast(result);</span>
			@SuppressWarnings(&quot;resource&quot;)
<span class="nc" id="L167">			OutputStream os = streamResult.getOutputStream();</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">			if (null != os) {</span>
<span class="nc" id="L169">				writer.write(os.toString()); // probably ByteArrayOutputStream</span>
				try {
<span class="nc" id="L171">					os.close();</span>
				}
<span class="nc" id="L173">				catch (IOException e) {</span>
<span class="nc" id="L174">				}</span>
			}
			else { // try system id or writer
<span class="nc" id="L177">				Path path = Paths.get(URI.create(streamResult.getSystemId()));</span>
				try {
<span class="nc" id="L179">					byte[] data = Files.readAllBytes(path);</span>
<span class="nc" id="L180">					writer.write(new String(data));</span>
				}
<span class="nc" id="L182">				catch (IOException e) {</span>
<span class="nc" id="L183">					LOGR.warning(e.getMessage());</span>
<span class="nc" id="L184">				}</span>
			}
<span class="nc" id="L186">		}</span>
		else {
<span class="nc" id="L188">			throw new IllegalArgumentException(&quot;Unsupported Result type:&quot; + result.getClass());</span>
		}
<span class="nc" id="L190">		return writer.toString();</span>
	}

	/**
	 * Evaluates an XPath 1.0 expression using the given context and returns the result as
	 * a node set.
	 * @param context The context node.
	 * @param expr An XPath expression.
	 * @param namespaceBindings A collection of namespace bindings for the XPath
	 * expression, where each entry maps a namespace URI (key) to a prefix (value).
	 * Standard bindings do not need to be declared (see
	 * {@link NamespaceBindings#withStandardBindings()}.
	 * @return A NodeList containing nodes that satisfy the expression (it may be empty).
	 * @throws XPathExpressionException If the expression cannot be evaluated for any
	 * reason.
	 */
	public static NodeList evaluateXPath(Node context, String expr, Map&lt;String, String&gt; namespaceBindings)
			throws XPathExpressionException {
<span class="fc" id="L208">		Object result = evaluateXPath(context, expr, namespaceBindings, XPathConstants.NODESET);</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">		if (!NodeList.class.isInstance(result)) {</span>
<span class="nc" id="L210">			throw new XPathExpressionException(&quot;Expression does not evaluate to a NodeList: &quot; + expr);</span>
		}
<span class="fc" id="L212">		return (NodeList) result;</span>
	}

	/**
	 * Evaluates an XPath expression using the given context and returns the result as the
	 * specified type.
	 *
	 * &lt;p&gt;
	 * &lt;strong&gt;Note:&lt;/strong&gt; The Saxon implementation supports XPath 2.0 expressions when
	 * using the JAXP XPath APIs (the default implementation will throw an exception).
	 * &lt;/p&gt;
	 * @param context The context node.
	 * @param expr An XPath expression.
	 * @param namespaceBindings A collection of namespace bindings for the XPath
	 * expression, where each entry maps a namespace URI (key) to a prefix (value).
	 * Standard bindings do not need to be declared (see
	 * {@link NamespaceBindings#withStandardBindings()}.
	 * @param returnType The desired return type (as declared in {@link XPathConstants} ).
	 * @return The result converted to the desired returnType.
	 * @throws XPathExpressionException If the expression cannot be evaluated for any
	 * reason.
	 */
	public static Object evaluateXPath(Node context, String expr, Map&lt;String, String&gt; namespaceBindings,
			QName returnType) throws XPathExpressionException {
<span class="fc" id="L236">		NamespaceBindings bindings = NamespaceBindings.withStandardBindings();</span>
<span class="fc" id="L237">		bindings.addAllBindings(namespaceBindings);</span>
<span class="fc" id="L238">		XPathFactory factory = XPATH_FACTORY;</span>
		// WARNING: If context node is Saxon NodeOverNodeInfo, the factory must
		// use the same Configuration object to avoid IllegalArgumentException
<span class="fc" id="L241">		XPath xpath = factory.newXPath();</span>
<span class="fc" id="L242">		xpath.setNamespaceContext(bindings);</span>
<span class="fc" id="L243">		Object result = xpath.evaluate(expr, context, returnType);</span>
<span class="fc" id="L244">		return result;</span>
	}

	/**
	 * Evaluates an XPath 2.0 expression using the Saxon s9api interfaces.
	 * @param xmlSource The XML Source.
	 * @param expr The XPath expression to be evaluated.
	 * @param nsBindings A collection of namespace bindings required to evaluate the XPath
	 * expression, where each entry maps a namespace URI (key) to a prefix (value); this
	 * may be {@code null} if not needed.
	 * @return An XdmValue object representing a value in the XDM data model; this is a
	 * sequence of zero or more items, where each item is either an atomic value or a
	 * node.
	 * @throws SaxonApiException If an error occurs while evaluating the expression; this
	 * always wraps some other underlying exception.
	 */
	public static XdmValue evaluateXPath2(Source xmlSource, String expr, Map&lt;String, String&gt; nsBindings)
			throws SaxonApiException {
<span class="fc" id="L262">		Processor proc = new Processor(false);</span>
<span class="fc" id="L263">		XPathCompiler compiler = proc.newXPathCompiler();</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">		if (null != nsBindings) {</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">			for (String nsURI : nsBindings.keySet()) {</span>
<span class="fc" id="L266">				compiler.declareNamespace(nsBindings.get(nsURI), nsURI);</span>
<span class="fc" id="L267">			}</span>
		}
<span class="fc" id="L269">		XPathSelector xpath = compiler.compile(expr).load();</span>
<span class="fc" id="L270">		DocumentBuilder builder = proc.newDocumentBuilder();</span>
<span class="fc" id="L271">		XdmNode node = null;</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">		if (DOMSource.class.isInstance(xmlSource)) {</span>
<span class="fc" id="L273">			DOMSource domSource = (DOMSource) xmlSource;</span>
<span class="fc" id="L274">			node = builder.wrap(domSource.getNode());</span>
<span class="fc" id="L275">		}</span>
		else {
<span class="fc" id="L277">			node = builder.build(xmlSource);</span>
		}
<span class="fc" id="L279">		xpath.setContextItem(node);</span>
<span class="fc" id="L280">		return xpath.evaluate();</span>
	}

	/**
	 * Evaluates an XQuery 1.0 expression using the Saxon s9api interfaces.
	 * @param source The XML Source.
	 * @param query The query expression.
	 * @param nsBindings A collection of namespace bindings required to evaluate the
	 * query, where each entry maps a namespace URI (key) to a prefix (value).
	 * @return An XdmValue object representing a value in the XDM data model.
	 * @throws SaxonApiException If an error occurs while evaluating the query (this
	 * always wraps some other underlying exception).
	 */
	public static XdmValue evaluateXQuery(Source source, String query, Map&lt;String, String&gt; nsBindings)
			throws SaxonApiException {
<span class="nc" id="L295">		Processor proc = new Processor(false);</span>
<span class="nc" id="L296">		XQueryCompiler xqCompiler = proc.newXQueryCompiler();</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">		if (null != nsBindings) {</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">			for (String nsURI : nsBindings.keySet()) {</span>
<span class="nc" id="L299">				xqCompiler.declareNamespace(nsBindings.get(nsURI), nsURI);</span>
<span class="nc" id="L300">			}</span>
		}
<span class="nc" id="L302">		XQueryExecutable xqExec = xqCompiler.compile(query);</span>
<span class="nc" id="L303">		XQueryEvaluator xqEval = xqExec.load();</span>
<span class="nc" id="L304">		xqEval.setSource(source);</span>
<span class="nc" id="L305">		return xqEval.evaluate();</span>
	}

	/**
	 * Creates a new Element having the specified qualified name. The element must be
	 * {@link Document#adoptNode(Node) adopted} when inserted into another Document.
	 * @param qName A QName object.
	 * @return An Element node (with a Document owner but no parent).
	 */
	public static Element createElement(QName qName) {
<span class="fc" id="L315">		Document doc = null;</span>
		try {
<span class="fc" id="L317">			doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();</span>
		}
<span class="nc" id="L319">		catch (ParserConfigurationException e) {</span>
<span class="nc" id="L320">			throw new RuntimeException(e);</span>
<span class="fc" id="L321">		}</span>
<span class="fc" id="L322">		Element elem = doc.createElementNS(qName.getNamespaceURI(), qName.getLocalPart());</span>
<span class="fc" id="L323">		return elem;</span>
	}

	/**
	 * Returns a List of all descendant Element nodes having the specified [namespace
	 * name] property. The elements are listed in document order.
	 * @param node The node to search from.
	 * @param namespaceURI An absolute URI denoting a namespace name.
	 * @return A List containing elements in the specified namespace; the list is empty if
	 * there are no elements in the namespace.
	 */
	public static List&lt;Element&gt; getElementsByNamespaceURI(Node node, String namespaceURI) {
<span class="nc" id="L335">		List&lt;Element&gt; list = new ArrayList&lt;Element&gt;();</span>
<span class="nc" id="L336">		NodeList children = node.getChildNodes();</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">		for (int i = 0; i &lt; children.getLength(); i++) {</span>
<span class="nc" id="L338">			Node child = children.item(i);</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">			if (child.getNodeType() != Node.ELEMENT_NODE)</span>
<span class="nc" id="L340">				continue;</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">			if (child.getNamespaceURI().equals(namespaceURI))</span>
<span class="nc" id="L342">				list.add((Element) child);</span>
		}
<span class="nc" id="L344">		return list;</span>
	}

	/**
	 * Transforms the content of a DOM Node using a specified XSLT stylesheet.
	 * @param xslt A Source object representing a stylesheet (XSLT 1.0 or 2.0).
	 * @param source A Node representing the XML source. If it is an Element node it will
	 * be imported into a new DOM Document.
	 * @return A DOM Document containing the result of the transformation.
	 */
	public static Document transform(Source xslt, Node source) {
<span class="nc" id="L355">		Document sourceDoc = null;</span>
<span class="nc" id="L356">		Document resultDoc = null;</span>
		try {
<span class="nc" id="L358">			resultDoc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">			if (source.getNodeType() == Node.DOCUMENT_NODE) {</span>
<span class="nc" id="L360">				sourceDoc = (Document) source;</span>
			}
			else {
<span class="nc" id="L363">				sourceDoc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();</span>
<span class="nc" id="L364">				sourceDoc.appendChild(sourceDoc.importNode(source, true));</span>
			}
		}
<span class="nc" id="L367">		catch (ParserConfigurationException pce) {</span>
<span class="nc" id="L368">			throw new RuntimeException(pce);</span>
<span class="nc" id="L369">		}</span>
<span class="nc" id="L370">		Processor processor = new Processor(false);</span>
<span class="nc" id="L371">		XsltCompiler compiler = processor.newXsltCompiler();</span>
		try {
<span class="nc" id="L373">			XsltExecutable exec = compiler.compile(xslt);</span>
<span class="nc" id="L374">			XsltTransformer transformer = exec.load();</span>
<span class="nc" id="L375">			transformer.setSource(new DOMSource(sourceDoc));</span>
<span class="nc" id="L376">			transformer.setDestination(new DOMDestination(resultDoc));</span>
<span class="nc" id="L377">			transformer.transform();</span>
		}
<span class="nc" id="L379">		catch (SaxonApiException e) {</span>
<span class="nc" id="L380">			throw new RuntimeException(e);</span>
<span class="nc" id="L381">		}</span>
<span class="nc" id="L382">		return resultDoc;</span>
	}

	/**
	 * Expands character entity ({@literal &amp;name;}) and numeric references (
	 * {@literal &amp;#xhhhh;} or {@literal &amp;dddd;}) that occur within a given string value.
	 * It may be necessary to do this before processing an XPath expression.
	 * @param value A string representing text content.
	 * @return A string with all included references expanded.
	 */
	public static String expandReferencesInText(String value) {
<span class="fc" id="L393">		StringBuilder wrapper = new StringBuilder(&quot;&lt;value&gt;&quot;);</span>
<span class="fc" id="L394">		wrapper.append(value).append(&quot;&lt;/value&gt;&quot;);</span>
<span class="fc" id="L395">		Reader reader = new StringReader(wrapper.toString());</span>
<span class="fc" id="L396">		String str = null;</span>
		try {
<span class="fc" id="L398">			XMLStreamReader xsr = STAX_FACTORY.createXMLStreamReader(reader);</span>
<span class="fc" id="L399">			xsr.nextTag(); // document element</span>
<span class="fc" id="L400">			str = xsr.getElementText();</span>
		}
<span class="nc" id="L402">		catch (XMLStreamException xse) {</span>
<span class="nc" id="L403">			LOGR.log(Level.WARNING, xse.getMessage(), xse);</span>
<span class="fc" id="L404">		}</span>
<span class="fc" id="L405">		return str;</span>
	}

	/**
	 * Creates a DOM Document with the given Element as the document element. A deep copy
	 * of the element is imported; the source element is not altered.
	 * @param elem An Element node.
	 * @return A Document node.
	 */
	public static Document importElement(Element elem) {
<span class="nc" id="L415">		javax.xml.parsers.DocumentBuilder docBuilder = null;</span>
		try {
<span class="nc" id="L417">			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span>
<span class="nc" id="L418">			factory.setNamespaceAware(true);</span>
<span class="nc" id="L419">			docBuilder = factory.newDocumentBuilder();</span>
		}
<span class="nc" id="L421">		catch (ParserConfigurationException ex) {</span>
<span class="nc" id="L422">			LOGR.log(Level.WARNING, null, ex);</span>
<span class="nc" id="L423">		}</span>
<span class="nc" id="L424">		Document newDoc = docBuilder.newDocument();</span>
<span class="nc" id="L425">		Node newNode = newDoc.importNode(elem, true);</span>
<span class="nc" id="L426">		newDoc.appendChild(newNode);</span>
<span class="nc" id="L427">		return newDoc;</span>
	}

	/**
	 * Returns a List view of the nodes in the given NodeList collection.
	 * @param nodeList An ordered collection of DOM nodes.
	 * @return A List containing the original sequence of Node objects.
	 */
	public static List&lt;Node&gt; asList(NodeList nodeList) {
<span class="nc" id="L436">		List&lt;Node&gt; nodes = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">		for (int i = 0; i &lt; nodeList.getLength(); i++) {</span>
<span class="nc" id="L438">			nodes.add(nodeList.item(i));</span>
		}
<span class="nc" id="L440">		return nodes;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>